<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8">
  <title>Raytracing - Kaca Lebih Cerah Final</title>
  <style>
    body { margin: 0; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; background-color: #202025; color: white; font-family: sans-serif;}
    canvas { border: 1px solid #303035; box-shadow: 0 0 12px rgba(0,0,0,0.5); margin-top: 10px;}
    .controls { margin-bottom: 10px; }
    .controls label { margin-right: 5px; }
  </style>
</head>
<body>
  <div class="controls">
    <label for="iorSlider">Glass Sphere IoR:</label>
    <input type="range" id="iorSlider" min="1.0" max="2.0" value="1.5" step="0.01">
    <span id="iorValue">1.5</span>
  </div>
  <canvas id="canvas" width="500" height="500"></canvas>

  <script src="helper.js"></script>
  <script>
    (function() {
      const canvas = document.getElementById("canvas");
      const ctx = canvas.getContext("2d");
      const width = canvas.width;
      const height = canvas.height;

      const iorSlider = document.getElementById('iorSlider');
      const iorValueSpan = document.getElementById('iorValue');

      const epsilon = 0.0001;
      const MAX_RECURSION_DEPTH = 5;
      const IOR_AIR = 1.0;

      const planeLevelY = -1.0;

      const mainGlassSphereRadius = 1.0;
      const greenSolidSphereRadius = 0.6;
      const blueSolidSphereRadius = 0.55;

      const mainGlassSphereCenterY = planeLevelY + mainGlassSphereRadius;
      const greenSolidSphereCenterY = planeLevelY + greenSolidSphereRadius;
      const blueSolidSphereCenterY = planeLevelY + blueSolidSphereRadius;

      let spheres = [];

      const plane = {
        point: createVec3(0, planeLevelY, 0),
        normal: createVec3(0, 1, 0),
        color1: [30, 30, 30],
        color2: [225, 225, 225],
        specular: 0.15, shininess: 25, reflectivity: 0.45,
        isPlane: true
      };

      const cameraOrigin = createVec3(0, 0.8, 3.5);
      // Cahaya sedikit lebih dari atas untuk menerangi lantai dan objek
      const lightDirection = normalizeVec3(createVec3(), createVec3(0.5, -0.85, -0.3));
      const lightColor = [1, 1, 1];
      // NAIKKAN AMBIENT GLOBAL SECARA SIGNIFIKAN LAGI
      const ambientLightIntensity = [0.25, 0.25, 0.28];
      // BACKGROUND ATAS JUGA DIBUAT LEBIH TERANG
      const backgroundColor = [45, 50, 60];

      let imageData;

      const _oc = createVec3(); /* ... Vektor temporary sama ... */
      const _hitPointTemp = createVec3();
      const _normalTemp = createVec3();
      const _P0O = createVec3();
      const _vectorToLight = createVec3();
      const _reflVecForLighting = createVec3();
      const _viewDirFromHit = createVec3();
      const _shadowRayOrigin = createVec3();
      const _shadowRayDirToLight = createVec3();
      const _reflectionDir = createVec3();
      const _refractionDir = createVec3();
      const _tempVec1 = createVec3();


      function defineSpheres(currentGlassIoR) {
        spheres = [
          { center: createVec3(0.0, mainGlassSphereCenterY, -1.8), // Kaca utama
            radius: mainGlassSphereRadius,
            color: [255, 255, 255], // Tint PUTIH
            specular: 0.9, shininess: 300,
            reflectivity: 0.15, // Kurangi reflektivitas permukaan agar fokus refraksi
            isRefractive: true, ior: currentGlassIoR, transparency: 0.98
          },
          { center: createVec3(-2.0, greenSolidSphereCenterY, -3.0), // Hijau di BELAKANG KIRI
            radius: greenSolidSphereRadius,
            color: [50, 220, 100], specular: 0.5, shininess: 60, reflectivity: 0.25, // Buat hijau lebih terang
            isRefractive: false
          },
           { center: createVec3(1.7, blueSolidSphereCenterY, -1.5), // Biru di DEPAN KANAN
             radius: blueSolidSphereRadius,
             color: [60, 100, 230], specular: 0.4, shininess: 50, reflectivity: 0.20, // Buat biru lebih terang
             isRefractive: false
           }
        ];
      }

      function intersectSphere(rayOrigin, rayDir, sphere) { /* ... Sama ... */
        subtractVec3(_oc, rayOrigin, sphere.center);
        let a = dotVec3(rayDir, rayDir);
        let b = 2.0 * dotVec3(_oc, rayDir);
        let c = dotVec3(_oc, _oc) - sphere.radius * sphere.radius;
        let discriminant = b * b - 4 * a * c;

        if (discriminant < 0) return null;
        let sqrtDiscriminant = Math.sqrt(discriminant);
        let t0 = (-b - sqrtDiscriminant) / (2.0 * a);
        let t1 = (-b + sqrtDiscriminant) / (2.0 * a);
        let t = -1;
        if (t0 > epsilon && t1 > epsilon) t = Math.min(t0, t1);
        else if (t0 > epsilon) t = t0;
        else if (t1 > epsilon) t = t1;
        else return null;

        scaleAndAddVec3(_hitPointTemp, rayOrigin, rayDir, t);
        subtractVec3(_normalTemp, _hitPointTemp, sphere.center);
        normalizeVec3(_normalTemp, _normalTemp);
        return { t, point: cloneVec3(_hitPointTemp), normal: cloneVec3(_normalTemp), object: sphere };
      }
      function intersectPlane(rayOrigin, rayDir, planeObj) { /* ... Sama ... */
        const N_plane = planeObj.normal;
        const P0_plane = planeObj.point;
        const DdotN = dotVec3(rayDir, N_plane);
        if (Math.abs(DdotN) < epsilon) return null;
        subtractVec3(_P0O, P0_plane, rayOrigin);
        let t = dotVec3(_P0O, N_plane) / DdotN;
        if (t < epsilon) return null;
        scaleAndAddVec3(_hitPointTemp, rayOrigin, rayDir, t);
        return { t, point: cloneVec3(_hitPointTemp), normal: cloneVec3(N_plane), object: planeObj };
      }
      function refract(incident, normal, iorRatio_n1_over_n2) { /* ... Sama ... */
        const cosI = -dotVec3(normal, incident);
        const sinT2 = iorRatio_n1_over_n2 * iorRatio_n1_over_n2 * (1.0 - cosI * cosI);
        if (sinT2 > 1.00001) return null; // TIR
        const cosT = Math.sqrt(Math.max(0, 1.0 - sinT2));
        scaleVec3(_refractionDir, incident, iorRatio_n1_over_n2);
        scaleVec3(_tempVec1, normal, iorRatio_n1_over_n2 * cosI - cosT);
        addVec3(_refractionDir, _refractionDir, _tempVec1);
        normalizeVec3(_refractionDir, _refractionDir);
        return _refractionDir;
      }
      function calculateDirectLighting(hitPoint, normal, viewDirection, objectColor, materialSpecular, materialShininess, isGlass = false) { /* ... Sama ... */
        let localColor = createVec3();
        let ambientFactor = isGlass ? 0.0 : 1.0;
        let diffuseFactor = isGlass ? 0.0 : 1.0;

        setVec3(localColor,
            objectColor[0] * ambientLightIntensity[0] * ambientFactor,
            objectColor[1] * ambientLightIntensity[1] * ambientFactor,
            objectColor[2] * ambientLightIntensity[2] * ambientFactor
        );

        let isInShadow = false;
        scaleAndAddVec3(_shadowRayOrigin, hitPoint, normal, epsilon * 5);
        negateVec3(_shadowRayDirToLight, lightDirection);
        for (let s_idx = 0; s_idx < spheres.length; s_idx++) {
            const shadowHit = intersectSphere(_shadowRayOrigin, _shadowRayDirToLight, spheres[s_idx]);
            if (shadowHit && shadowHit.t > epsilon) { isInShadow = true; break; }
        }

        if (!isInShadow) {
            negateVec3(_vectorToLight, lightDirection);
            let NdotL = dotVec3(normal, _vectorToLight);
            let diffuseIntensity = Math.max(0, NdotL);

            if (diffuseIntensity > 0) {
                localColor[0] += objectColor[0] * diffuseIntensity * lightColor[0] * diffuseFactor;
                localColor[1] += objectColor[1] * diffuseIntensity * lightColor[1] * diffuseFactor;
                localColor[2] += objectColor[2] * diffuseIntensity * lightColor[2] * diffuseFactor;
            }
            if (materialSpecular > 0 && NdotL > 0) {
                scaleVec3(_reflVecForLighting, normal, 2 * NdotL);
                subtractVec3(_reflVecForLighting, _reflVecForLighting, _vectorToLight);
                normalizeVec3(_reflVecForLighting, _reflVecForLighting);
                negateVec3(_viewDirFromHit, viewDirection);
                normalizeVec3(_viewDirFromHit, _viewDirFromHit);
                let RdotV = dotVec3(_reflVecForLighting, _viewDirFromHit);
                let specularIntensity = Math.pow(Math.max(0, RdotV), materialShininess);
                if (specularIntensity > 0) {
                    localColor[0] += 255 * lightColor[0] * specularIntensity * materialSpecular;
                    localColor[1] += 255 * lightColor[1] * specularIntensity * materialSpecular;
                    localColor[2] += 255 * lightColor[2] * specularIntensity * materialSpecular;
                }
            }
        }
        return localColor;
      }

      function traceRay(rayOrigin, rayDirection, depth) {
        if (depth <= 0) {
            let bgHitColor = createVec3(backgroundColor[0], backgroundColor[1], backgroundColor[2]);
            if (depth < MAX_RECURSION_DEPTH -1 && depth > -MAX_RECURSION_DEPTH ) {
                // Pencerahan background untuk sinar sekunder/tersier
                bgHitColor[0] = Math.max(bgHitColor[0], 75); // Tingkatkan lagi
                bgHitColor[1] = Math.max(bgHitColor[1], 75);
                bgHitColor[2] = Math.max(bgHitColor[2], 85);
            }
            return bgHitColor;
        }

        let closestHit = null; /* ... Pencarian Intersection Sama ... */
        for (let k = 0; k < spheres.length; k++) {
            const result = intersectSphere(rayOrigin, rayDirection, spheres[k]);
            if (result && (!closestHit || result.t < closestHit.t)) closestHit = result;
        }
        const planeHit = intersectPlane(rayOrigin, rayDirection, plane);
        if (planeHit && (!closestHit || planeHit.t < closestHit.t)) closestHit = planeHit;

        if (closestHit) {
            const hitObject = closestHit.object;
            const hitPoint = closestHit.point;
            const N_surface = closestHit.normal;

            let objectColorForDiffuse = hitObject.isPlane ? ( (Math.floor(hitPoint[0]*1.0) + Math.floor(hitPoint[2]*1.0)) % 2 === 0 ? plane.color1 : plane.color2 ) : hitObject.color;

            let finalColor = createVec3(0,0,0);
            let reflectedColor = createVec3(0,0,0);
            let refractedColor = createVec3(0,0,0);

            let cosIncident = -dotVec3(rayDirection, N_surface);
            let n1 = IOR_AIR, n2 = hitObject.ior || IOR_AIR;
            let normalForFresnelAndRefraction = cloneVec3(N_surface);

            if (cosIncident < 0) {
                cosIncident = -cosIncident;
                let temp_n = n1; n1 = n2; n2 = temp_n;
                negateVec3(normalForFresnelAndRefraction, normalForFresnelAndRefraction);
            }
            let R0 = Math.pow((n1 - n2) / (n1 + n2), 2);
            if (!hitObject.isRefractive && hitObject.reflectivity !== undefined) {
                 R0 = hitObject.reflectivity;
            } else if (!hitObject.isRefractive) { R0 = 0; }

            let fresnelReflectance = R0 + (1 - R0) * Math.pow(1 - cosIncident, 5);
            fresnelReflectance = Math.max(0, Math.min(1, fresnelReflectance));
            let actualReflectivityForSurface = hitObject.isRefractive ? fresnelReflectance : (hitObject.reflectivity || 0);

            if (actualReflectivityForSurface > epsilon ) {
                let dotNI = dotVec3(N_surface, rayDirection);
                scaleVec3(_reflectionDir, N_surface, 2 * dotNI);
                subtractVec3(_reflectionDir, rayDirection, _reflectionDir);
                normalizeVec3(_reflectionDir, _reflectionDir);
                const reflectionOrigin = createVec3(); scaleAndAddVec3(reflectionOrigin, hitPoint, _reflectionDir, epsilon * 2);
                copyVec3(reflectedColor, traceRay(reflectionOrigin, _reflectionDir, depth - 1));
            }

            if (hitObject.isRefractive && hitObject.transparency > 0) {
                let fresnelTransmittance = 1.0 - fresnelReflectance;
                if (fresnelTransmittance * hitObject.transparency > epsilon) {
                    const refractedDir = refract(rayDirection, normalForFresnelAndRefraction, n1 / n2);
                    if (refractedDir) {
                        const internalRayOrigin = createVec3(); scaleAndAddVec3(internalRayOrigin, hitPoint, refractedDir, epsilon * 2);
                        if (!hitObject.isPlane) {
                           subtractVec3(_oc,internalRayOrigin,hitObject.center);let a_i=dotVec3(refractedDir,refractedDir),b_i=2.*dotVec3(_oc,refractedDir),c_i=dotVec3(_oc,_oc)-hitObject.radius*hitObject.radius;let d_i=b_i*b_i-4*a_i*c_i;
                            if(d_i>=0){let t_ex=(-b_i+Math.sqrt(d_i))/(2*a_i);
                                if(t_ex>epsilon){const exP=createVec3();scaleAndAddVec3(exP,internalRayOrigin,refractedDir,t_ex);
                                const N_ex=createVec3();subtractVec3(N_ex,exP,hitObject.center);normalizeVec3(N_ex,N_ex);
                                const finalRD=refract(refractedDir,N_ex,hitObject.ior/IOR_AIR);
                                if(finalRD){const finalRO=createVec3();scaleAndAddVec3(finalRO,exP,finalRD,epsilon*2);copyVec3(refractedColor,traceRay(finalRO,finalRD,depth-1));}}
                            }
                        } else {copyVec3(refractedColor,traceRay(internalRayOrigin,refractedDir,depth-1));}
                    }
                }
                let surfaceDirectSpecular = calculateDirectLighting(hitPoint, N_surface, rayDirection, [0,0,0], hitObject.specular, hitObject.shininess, true);

                // Penggabungan untuk Kaca:
                let transmissiveColorComponent = createVec3();
                // NAIKKAN LAGI refractionBrightnessBoost
                let refractionBrightnessBoost = 2.2; // Coba nilai 2.0 - 3.0
                if(hitObject.ior < 1.35) refractionBrightnessBoost = 2.8;
                scaleVec3(transmissiveColorComponent, refractedColor, fresnelTransmittance * hitObject.transparency * refractionBrightnessBoost);

                let reflectiveColorComponent = createVec3();
                scaleVec3(reflectiveColorComponent, reflectedColor, actualReflectivityForSurface);

                finalColor[0] = surfaceDirectSpecular[0] + reflectiveColorComponent[0] + transmissiveColorComponent[0];
                finalColor[1] = surfaceDirectSpecular[1] + reflectiveColorComponent[1] + transmissiveColorComponent[1];
                finalColor[2] = surfaceDirectSpecular[2] + reflectiveColorComponent[2] + transmissiveColorComponent[2];

                // Tambahkan sedikit "global illumination" pada kaca, berdasarkan ambient global
                // Ini akan memastikan kaca tidak hitam total jika refraksi/refleksi gelap
                let glassBaseIlluminationFactor = 0.15; // Faktor kecerahan dasar untuk kaca
                finalColor[0] += 255 * ambientLightIntensity[0] * glassBaseIlluminationFactor * hitObject.transparency;
                finalColor[1] += 255 * ambientLightIntensity[1] * glassBaseIlluminationFactor * hitObject.transparency;
                finalColor[2] += 255 * ambientLightIntensity[2] * glassBaseIlluminationFactor * hitObject.transparency;


            } else { // Objek Padat
                let directLighting = calculateDirectLighting(hitPoint, N_surface, rayDirection, objectColorForDiffuse, hitObject.specular, hitObject.shininess, false);
                finalColor[0] = directLighting[0] * (1 - actualReflectivityForSurface) + reflectedColor[0];
                finalColor[1] = directLighting[1] * (1 - actualReflectivityForSurface) + reflectedColor[1];
                finalColor[2] = directLighting[2] * (1 - actualReflectivityForSurface) + reflectedColor[2];
            }
            return finalColor;
        } else {
            return createVec3(backgroundColor[0], backgroundColor[1], backgroundColor[2]);
        }
      }

      function renderScene() { /* ... Sama ... */
        console.time("RenderTime");
        imageData = ctx.createImageData(width, height);
        const currentGlassIoR = parseFloat(iorSlider.value);
        iorValueSpan.textContent = currentGlassIoR.toFixed(2);
        defineSpheres(currentGlassIoR);
        for (let j = 0; j < height; j++) {
          for (let i = 0; i < width; i++) {
            let u = (i + 0.5) / width * 2 - 1, v = 1 - (j + 0.5) / height * 2;
            let aspectRatio = width / height; u *= aspectRatio;
            let dir = createVec3(u, v, -2.0); // FOV, -2.0 agar objek utama di tengah
            normalizeVec3(dir, dir);
            let tracedColorVec3 = traceRay(cameraOrigin, dir, MAX_RECURSION_DEPTH);
            let index = (j * width + i) * 4;
            imageData.data[index+0]=Math.min(255,Math.max(0,tracedColorVec3[0]));
            imageData.data[index+1]=Math.min(255,Math.max(0,tracedColorVec3[1]));
            imageData.data[index+2]=Math.min(255,Math.max(0,tracedColorVec3[2]));
            imageData.data[index+3]=255;
          }
        }
        ctx.putImageData(imageData,0,0);
        console.timeEnd("RenderTime");
        console.log("Raytracing Selesai.");
      }
      iorSlider.addEventListener('input', renderScene);
      renderScene();
    })();
  </script>
</body>
</html>